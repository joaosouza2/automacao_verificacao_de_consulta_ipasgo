import openpyxl
import logging
import time
import pandas as pd
import sys
import os
from pathlib import Path
from selenium import webdriver
from selenium.webdriver.chrome.options import Options
from selenium.webdriver.common.by import By
from selenium.webdriver.support.ui import WebDriverWait, Select
from selenium.webdriver.support import expected_conditions as EC
from selenium.common.exceptions import TimeoutException, NoSuchElementException

# Configuração de logging
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')

# Definir um excepthook para capturar exceções não tratadas
def excepthook(exc_type, exc_value, exc_traceback):
    if issubclass(exc_type, KeyboardInterrupt):
        # Permite que o KeyboardInterrupt seja tratado normalmente
        sys.__excepthook__(exc_type, exc_value, exc_traceback)
        return
    logging.error(f"Exceção não capturada: {exc_value}")

sys.excepthook = excepthook

class DataHandler:
    def __init__(self, file_path, sheet_name):
        self.file_path = file_path
        self.sheet_name = sheet_name
        self.df = pd.read_excel(file_path, sheet_name=sheet_name)
        self.df.columns = [col.upper().strip() for col in self.df.columns]
        if 'CONFIRMACOES' not in self.df.columns:
            self.df['CONFIRMACOES'] = ''
        if 'ERRO' not in self.df.columns:
            self.df['ERRO'] = ''

    def get_value(self, row_index, column_name):
        """Obtém o valor de uma coluna específica em uma linha específica."""
        try:
            value = self.df.at[row_index, column_name.upper()]
            return str(value) if not pd.isnull(value) else ""
        except KeyError:
            logging.error(f"A coluna '{column_name}' não foi encontrada.")
            return ""

    def update_value(self, row_index, column_name, value):
        """Atualiza o valor de uma célula específica."""
        try:
            self.df.at[row_index, column_name.upper()] = value
            logging.info(f"Valor atualizado na linha {row_index + 2}, coluna '{column_name}': {value}")
        except KeyError:
            logging.error(f"A coluna '{column_name}' não foi encontrada ao tentar atualizar o valor.")

    def save(self):
        """Salva o DataFrame de volta ao arquivo Excel."""
        try:
            # Salva no mesmo arquivo para evitar problemas
            self.df.to_excel(self.file_path, sheet_name=self.sheet_name, index=False)
            logging.info(f"Alterações salvas no arquivo Excel com sucesso: {self.file_path}")
        except Exception as e:
            error_message = getattr(e, 'message', str(e))
            logging.error(f"Erro ao salvar o arquivo Excel: {error_message}")

class BaseAutomation:
    def __init__(self):
        """Configurações gerais do WebDriver."""
        self.options = Options()
        self.options.add_argument("--start-maximized")
        self.driver = webdriver.Chrome(options=self.options)

    def wait_for_stability(self, timeout=10, check_interval=1):
        """Espera pela estabilidade da altura da página."""
        old_height = self.driver.execute_script("return document.body.scrollHeight;")
        for _ in range(timeout):
            time.sleep(check_interval)
            new_height = self.driver.execute_script("return document.body.scrollHeight;")
            if new_height == old_height:
                break
            old_height = new_height

    def safe_click(self, by_locator):
        """Tenta clicar no elemento várias vezes se for interceptado."""
        for _ in range(3):
            try:
                element = WebDriverWait(self.driver, 5).until(EC.element_to_be_clickable(by_locator))
                element.click()
                logging.info(f"Elemento clicado com sucesso: {by_locator}")
                return
            except Exception as e:
                error_message = getattr(e, 'msg', str(e))
                logging.warning(f"Erro ao clicar no elemento: {error_message}")
                time.sleep(1)
        raise Exception("Não foi possível clicar no elemento após várias tentativas.")

    def acessar_com_reattempt(self, by_locator, attempts=3):
        """Tenta acessar um elemento várias vezes."""
        for attempt in range(attempts):
            try:
                element = WebDriverWait(self.driver, 10).until(EC.element_to_be_clickable(by_locator))
                logging.info(f"Elemento encontrado: {by_locator}")
                return element
            except TimeoutException:
                logging.warning(f"Tentativa {attempt + 1} falhou. Tentando novamente...")
                time.sleep(1)
        raise Exception(f"Não foi possível acessar o elemento após {attempts} tentativas.")





class VerificationIPASGO(BaseAutomation):
    def __init__(self, data_handler):
        super().__init__()
        self.data_handler = data_handler
        self.row_index = 0  # Inicie com o índice desejado

    ###################################################################
        # Caminho para o arquivo txt onde as confirmações serão salvas
    ###################################################################
        self.txt_file_path = r"C:\Users\joaop\OneDrive\Área de Trabalho\Verificação_prodecimento_ipasgo\automacao_verificacao_de_consulta_ipasgo\salvamento_datas_confirmação.txt"





    def get_value(self, row_index, column_name):
        """Obtém o valor de uma coluna específica em uma linha específica."""
        try:
            value = self.df.at[row_index, column_name.upper()]
            # Converte para string, removendo ".0" se for número decimal
            if isinstance(value, float) and value.is_integer():
                value = int(value)  # Remove a parte decimal, mantendo como inteiro
            return str(value).strip() if value else ""
        except KeyError:
            logging.error(f"A coluna '{column_name}' não foi encontrada.")
            return ""





    def acessar_portal_ipasgo(self):
        """Executa o fluxo principal do IPASGO."""
        try:
            self.driver.get("https://portalos.ipasgo.go.gov.br/Portal_Dominio/PrestadorLogin.aspx")
            self.wait_for_stability(timeout=10)

            matricula_input = self.acessar_com_reattempt((By.ID, "SilkUIFramework_wt13_block_wtUsername_wtUserNameInput2"))
            matricula_input.send_keys('14898500')

            senha_input = self.acessar_com_reattempt((By.ID, "SilkUIFramework_wt13_block_wtPassword_wtPasswordInput"))
            senha_input.send_keys('Clmf2024')

            self.safe_click((By.ID, "SilkUIFramework_wt13_block_wtAction_wtLoginButton"))

            # Verificar se o alerta está dentro de um iframe (opcional)
            try:
                # Localiza todos os iframes na página
                iframes = self.driver.find_elements(By.TAG_NAME, "iframe")
                for iframe in iframes:
                    self.driver.switch_to.frame(iframe)
                    try:
                        fechar_alerta = WebDriverWait(self.driver, 5).until(
                            EC.element_to_be_clickable((By.XPATH, "//a[contains(@id, 'wt15')]/span[contains(@class, 'fa-close')]"))
                        )
                        fechar_alerta.click()
                        logging.info("Alerta detectado e fechado dentro de um iframe.")
                        self.driver.switch_to.default_content()
                        self.wait_for_stability(timeout=5)
                        break  # Sai do loop após fechar o alerta
                    except TimeoutException:
                        self.driver.switch_to.default_content()
                        continue
            except Exception as e:
                pass

            self.wait_for_stability(timeout=10)

            link_portal_webplan = self.acessar_com_reattempt((By.XPATH, "//*[@id='IpasgoTheme_wt16_block_wtMainContent_wtSistemas_ctl08_SilkUIFramework_wt36_block_wtActions_wtModulos_SilkUIFramework_wt9_block_wtContent_wtModuloPortalTable_ctl04_wt2']/span"))
            self.scroll_and_click(link_portal_webplan)

            WebDriverWait(self.driver, 20).until(EC.number_of_windows_to_be(2))
            self.driver.switch_to.window(self.driver.window_handles[1])

            self.acessar_com_reattempt((By.ID, "menuPrincipal"))

            time.sleep(4)
            self.executar_fluxo()
        except Exception as e:
            error_message = getattr(e, 'msg', str(e))
            logging.error(f"Erro ao acessar o portal IPASGO: {error_message}")
            # Não atualizar a coluna 'ERRO' no Excel





    def executar_fluxo(self):
        """Executa o fluxo de interações após o login no portal IPASGO."""
        try:
            self.localizar_procedimentos()
            self.Guia_operadora()
            self.abrir_confirmar_procedimentos()
            # Após executar 'confirmar_procedimentos', parar o script
            logging.info("Fluxo concluído. Aguardando para análise.")
            input("Pressione Enter para encerrar o script.")
        except Exception as e:
            error_message = getattr(e, 'msg', str(e))
            logging.error(f"Erro ao executar o fluxo: {error_message}")
            # Não atualizar a coluna 'ERRO' no Excel







    def scroll_and_click(self, element):
        """Rola a página para o elemento e clica nele."""
        self.driver.execute_script("arguments[0].scrollIntoView(true);", element)
        time.sleep(2)
        element.click()







    def localizar_procedimentos(self):
        """Função para localizar e clicar no elemento 'localizar-procedimentos'."""
        try:
            logging.info("Localizando o menu de procedimentos.")
            procedimentos_button = self.acessar_com_reattempt((By.CSS_SELECTOR, ".localizar-procedimentos-icon"))
            self.scroll_and_click(procedimentos_button)
            time.sleep(5)

            # Verifica se o alerta aparece e lida com ele se necessário
            self.close_alert_if_present()

        except Exception as e:
            error_message = getattr(e, 'msg', str(e))
            logging.error(f"Erro ao acessar o menu de procedimentos: {error_message}")
            # Não atualizar a coluna 'ERRO' no Excel






    def close_alert_if_present(self):
        """Fecha o alerta se estiver presente."""
        try:
            logging.info("Verificando se o alerta está presente.")
            alerta = WebDriverWait(self.driver, 5).until(EC.visibility_of_element_located((By.XPATH, '//*[@id="button-1"]')))
            alerta.click()
            logging.info("Alerta fechado com sucesso.")
        except TimeoutException:
            logging.info("Nenhum alerta encontrado, continuando o processo.")






    def Guia_operadora(self):
        """Função para inserir o número da guia para localizar procedimento usando dados da planilha."""
        try:
            numero_guia = self.data_handler.get_value(self.row_index, 'GUIA_COD')
            logging.info("Localizando o campo de número da guia.")

            guia_input = self.acessar_com_reattempt((By.CSS_SELECTOR, 'div.input-group > input.form-control.small'))
            guia_input.send_keys(str(numero_guia))
            logging.info(f"Número da guia preenchido com sucesso: {numero_guia}")

            search_button = self.acessar_com_reattempt((By.XPATH, "//div[contains(@class, 'input-group')]//span[contains(@class, 'fa-search') and contains(@class, 'pointer')]"))
            search_button.click()

            time.sleep(2)

            self.driver.execute_script("window.scrollTo(0, document.body.scrollHeight);")
            time.sleep(2)

        except Exception as e:
            error_message = getattr(e, 'msg', str(e))
            logging.error(f"Erro ao preencher o número da guia: {error_message}")
            # Não atualizar a coluna 'ERRO' no Excel





    def abrir_confirmar_procedimentos(self):
        """Função para confirmar procedimentos executados."""
        try:
            logging.info("Iniciando o processo de confirmação dos procedimentos.")
            confirmar_button = self.acessar_com_reattempt((By.XPATH, '//*[@id="localizarprocedimentos"]/div[2]/div/div[2]/div/div[2]/div[1]/div/div/div/div[2]/div[2]/div/div[1]/div/div[1]/div[2]/div/i[2]'))
            confirmar_button.click()
            logging.info("Botão de confirmação clicado com sucesso.")
            time.sleep(2)
            self.confirmar_data_procedimentos()
        except Exception as e:
            error_message = getattr(e, 'msg', str(e))
            logging.error(f"Erro ao tentar confirmar os procedimentos: {error_message}")
            # Não atualizar a coluna 'ERRO' no Excel





    def confirmar_data_procedimentos(self):
        """Captura os textos de confirmação dos procedimentos exibidos no modal e salva em uma lista."""
        try:
            logging.info("Iniciando captura de confirmações dos procedimentos.")

            # Aguardando a presença do modal
            modal = WebDriverWait(self.driver, 10).until(
                EC.visibility_of_element_located((By.ID, 'confirmar-procedimentos-modal'))
            )
            logging.info("Modal de confirmação está visível.")

            # Localiza todos os itens de confirmação dentro do modal
            confirmacao_itens = modal.find_elements(By.XPATH, '//*[@id="confirmar-procedimentos-modal"]/div/div/div[2]/div[2]/div/div[2]/div/div')

            self.confirmation_status_list = []  # Inicializa a lista para armazenar os status

            for idx, item in enumerate(confirmacao_itens):
                # Captura o texto do elemento de confirmação
                texto_confirmacao = item.find_element(By.XPATH, './/span[starts-with(@data-bind, "text: IsConfirmado()")]').text.strip()
                self.confirmation_status_list.append(texto_confirmacao)
                logging.info(f"Confirmação capturada na posição {idx + 1}: {texto_confirmacao}")

            # Atualiza a coluna 'CONFIRMACOES' no Excel
            confirmacoes_texto = "; ".join(self.confirmation_status_list)
            self.data_handler.update_value(self.row_index, 'CONFIRMACOES', confirmacoes_texto)
            self.data_handler.save()

            # Escreve as confirmações no arquivo .txt
            with open(self.txt_file_path, 'a', encoding='utf-8') as f:
                f.write(f"Linha {self.row_index + 2}: {confirmacoes_texto}\n")

            logging.info(f"Confirmações capturadas e salvas em '{self.txt_file_path}'.")

            # Chama a função para processar os procedimentos não confirmados
            self.Clicar_confirmar_procedimento()

        except Exception as e:
            logging.error(f"Erro ao capturar confirmações: {e}")
    





    def Clicar_confirmar_procedimento(self):
        """
        Verifica os elementos na lista de confirmações capturada na função anterior.
        Processa apenas a primeira linha com 'Não confirmado'.
        """
        try:
            logging.info("Iniciando processamento do primeiro procedimento não confirmado.")

            # Verificar se a lista de status foi preenchida
            if not hasattr(self, 'confirmation_status_list') or not self.confirmation_status_list:
                logging.error("Lista de status de confirmação está vazia ou não foi definida.")
                return

            # Percorre cada status na lista
            for idx, status_text in enumerate(self.confirmation_status_list):
                position = idx + 1  # As posições começam em 1

                logging.info(f"Status do procedimento na posição {position}: '{status_text}'")

                if status_text == "Não confirmado":
                    # Construir o XPath para o item na posição correspondente
                    item_xpath = f'//*[@id="confirmar-procedimentos-modal"]/div/div/div[2]/div[2]/div/div[2]/div/div[{position}]'
                    try:
                        # Localizar o item correspondente
                        item = self.driver.find_element(By.XPATH, item_xpath)
                        logging.info(f"Procedimento na posição {position} não está confirmado. Confirmando agora...")

                        # Dentro desse item, localizar o elemento para clicar
                        # O XPath fornecido é: //*[@id="span-cartao-magnetico"]/span[1]
                        # Tentaremos localizar dentro do item
                        try:
                            confirm_button = item.find_element(By.XPATH, './/*[@id="span-cartao-magnetico"]/span[1]')
                        except NoSuchElementException:
                            # Se não encontrado dentro do item, procurar no contexto global
                            confirm_button = self.driver.find_element(By.XPATH, '//*[@id="span-cartao-magnetico"]/span[1]')

                        confirm_button.click()
                        logging.info(f"Botão de confirmar clicado na posição {position}.")

                        # Aqui, você pode adicionar interações adicionais necessárias para confirmar o procedimento
                        # Por exemplo, preencher formulários, clicar em outros botões, etc.

                        # Identificação para interações adicionais para a confirmaçao do atendimento. 
                        # -------------------------------------------------
                        # Após clicar no botão, identificar o campo que se abre
                        try:
                            logging.info("Tentando localizar o campo de número da carteira após a confirmação.")
                            
                            # Aguarde até que o campo esteja visível
                            campo_carteira = WebDriverWait(self.driver, 10).until(
                                EC.visibility_of_element_located((By.XPATH, '//*[@id="numeroDaCarteiraConfirmacao"]'))
                            )
                            logging.info("Campo 'numeroDaCarteiraConfirmacao' localizado com sucesso.")
                            
                            # Obter o valor da coluna "COLUNA1" do Excel para a linha atual
                            numero_carteira = self.data_handler.get_value(self.row_index, 'COLUNA1')
                            if not numero_carteira:
                                raise Exception("Número da carteira não encontrado no Excel para a linha atual.")
                            
                            # Preencher o campo com o valor extraído do Excel
                            campo_carteira.send_keys(numero_carteira)
                            logging.info(f"Campo 'numeroDaCarteiraConfirmacao' preenchido com o valor: {numero_carteira}")
                            
                            # Aqui, você pode adicionar interações adicionais necessárias, como clicar em "Confirmar"
                            # Por exemplo, localizar e clicar no botão "Confirmar"
                            botao_confirmar = WebDriverWait(self.driver, 10).until(
                                EC.element_to_be_clickable((By.XPATH, '//button[contains(@class, "confirmar-procedimento-btn")]'))
                            )
                            botao_confirmar.click()
                            logging.info("Botão de confirmação clicado com sucesso após preencher o número da carteira.")
                            
                        except Exception as e:
                            logging.error(f"Erro ao interagir com o campo 'numeroDaCarteiraConfirmacao': {e}")
                            # Atualizar a coluna 'ERRO' no Excel com a mensagem de erro
                            self.data_handler.update_value(self.row_index, 'ERRO', f"Erro no campo 'numeroDaCarteiraConfirmacao': {e}")
                            self.data_handler.save()

                        # Sua lógica adicional aqui
                        # -------------------------------------------------

                        # Opcional: Após as interações adicionais, você pode atualizar o status
                        # Aguardar até que o status mude para "Confirmado {data}"
                        status_element = item.find_element(By.XPATH, './/span[starts-with(@data-bind, "text: IsConfirmado()")]')
                        WebDriverWait(self.driver, 10).until(
                            lambda driver: status_element.text.strip().startswith("Confirmado")
                        )
                        updated_status = status_element.text.strip()
                        logging.info(f"Novo status do procedimento na posição {position}: {updated_status}")

                        # Atualizar o status na lista
                        self.confirmation_status_list[idx] = updated_status

                    except Exception as e:
                        logging.error(f"Erro ao confirmar o procedimento na posição {position}: {e}")
                        # Decida se deseja continuar ou não
                        # Neste caso, como só processamos o primeiro, podemos sair do loop
                        break

                    # Após processar o primeiro "Não confirmado", interromper o loop
                    break
                else:
                    logging.info(f"Procedimento na posição {position} já está confirmado.")

            logging.info("Processamento do primeiro procedimento não confirmado concluído.")

            # Atualizar a coluna 'CONFIRMACOES' no Excel após a confirmação
            confirmacoes_texto = "; ".join(self.confirmation_status_list)
            self.data_handler.update_value(self.row_index, 'CONFIRMACOES', confirmacoes_texto)
            self.data_handler.save()

        except Exception as e:
            self.handle_exception(e, "Erro ao processar o procedimento não confirmado")



# Exemplo de execução
if __name__ == "__main__":
    # Defina o caminho do arquivo e o nome da planilha
    file_path = r"C:\Users\joaop\OneDrive\Área de Trabalho\Verificação_prodecimento_ipasgo\automacao_verificacao_de_consulta_ipasgo\BASE_GUIAS_IPASGO_10-2024tTEST.xlsx"
    sheet_name = 'BaseSADT'

    # Crie uma instância de DataHandler
    data_handler = DataHandler(file_path, sheet_name)

    # Crie uma instância de VerificationIPASGO, passando o data_handler
    automacao = VerificationIPASGO(data_handler)

    # Defina o intervalo de linhas que deseja processar
    start_row = 8
    end_row = len(data_handler.df) - 1  # Processa todas as linhas

    # Itere sobre as linhas e processe cada uma
    for idx in range(start_row, end_row + 1):
        automacao.row_index = idx
        logging.info(f"Iniciando o processamento da linha {idx + 2}")
        try:
            automacao.acessar_portal_ipasgo()
            # Salve as alterações após processar cada linha
            data_handler.save()
            # Parar o loop após a execução
            break  # Remove esta linha se quiser continuar para as próximas linhas

        except Exception as e:
            error_message = getattr(e, 'msg', str(e))
            logging.error(f"Erro ao processar a linha {idx + 2}: {error_message}")
            # Atualiza a coluna 'ERRO' no Excel
            data_handler.update_value(idx, 'ERRO', error_message)
            data_handler.save()
            break  # Remove esta linha se quiser continuar para as próximas linhas

    # Não feche o WebDriver para manter a página aberta
    # automacao.driver.quit()
