import logging
import time
import pandas as pd
from selenium import webdriver
from selenium.webdriver.chrome.options import Options
from selenium.webdriver.common.by import By
from selenium.webdriver.support.ui import WebDriverWait
from selenium.webdriver.support import expected_conditions as EC
from selenium.common.exceptions import TimeoutException, NoSuchElementException

# Configuração de logging
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')

class BaseAutomation:
    def __init__(self):
        """Configurações gerais do WebDriver."""
        self.options = Options()
        self.options.add_argument("--start-maximized")  
        self.driver = webdriver.Chrome(options=self.options)  

    def wait_for_stability(self, timeout=10, check_interval=1):
        """Espera pela estabilidade da altura da página."""
        old_height = self.driver.execute_script("return document.body.scrollHeight;")
        for _ in range(timeout):
            time.sleep(check_interval)
            new_height = self.driver.execute_script("return document.body.scrollHeight;")
            if new_height == old_height:
                break
            old_height = new_height

    def safe_click(self, by_locator):
        """Tenta clicar no elemento várias vezes se for interceptado."""
        for _ in range(3):
            try:
                element = WebDriverWait(self.driver, 5).until(EC.element_to_be_clickable(by_locator))
                element.click()
                logging.info(f"Elemento clicado com sucesso: {by_locator}")
                return
            except Exception as e:
                logging.warning(f"Erro ao clicar no elemento: {e}")
                time.sleep(1)
        raise Exception("Não foi possível clicar no elemento após várias tentativas.")

    def acessar_com_reattempt(self, by_locator, attempts=3):
        """Tenta acessar um elemento várias vezes."""
        for attempt in range(attempts):
            try:
                element = WebDriverWait(self.driver, 10).until(EC.element_to_be_clickable(by_locator))
                logging.info(f"Elemento encontrado: {by_locator}")
                return element
            except TimeoutException:
                logging.warning(f"Tentativa {attempt + 1} falhou. Tentando novamente...")
                time.sleep(1)
        raise Exception(f"Não foi possível acessar o elemento após {attempts} tentativas.")

class VerificationIPASGO(BaseAutomation):
    def __init__(self):
        super().__init__()
        self.sheet_name = 'BaseSADT'
        self.file_path = r"C:\Users\SUPERVISÃO ADM\Desktop\RPA_verificação_ipasgo\BASE_GUIAS_IPASGO_10-2024tTEST.xlsx"
        self.df = pd.read_excel(self.file_path, sheet_name=self.sheet_name)
        self.row_index = 0  # Inicie com o índice desejado

    def get_excel_value(self, column_name):
        """Obtém o valor de uma coluna específica na linha atual da planilha."""
        try:
            value = str(self.df[column_name].iloc[self.row_index])
            return value
        except KeyError:
            return ""

    def acessar_portal_ipasgo(self):
        """Executa o fluxo principal do IPASGO."""
        try:
            self.driver.get("https://portalos.ipasgo.go.gov.br/Portal_Dominio/PrestadorLogin.aspx")
            self.wait_for_stability(timeout=10)

            matricula_input = self.acessar_com_reattempt((By.ID, "SilkUIFramework_wt13_block_wtUsername_wtUserNameInput2"))
            matricula_input.send_keys("14898500")

            senha_input = self.acessar_com_reattempt((By.ID, "SilkUIFramework_wt13_block_wtPassword_wtPasswordInput"))
            senha_input.send_keys("Clmf2024")

            self.safe_click((By.ID, "SilkUIFramework_wt13_block_wtAction_wtLoginButton"))

            # Verificar se o alerta está dentro de um iframe (opcional)
            try:
                # Localiza todos os iframes na página
                iframes = self.driver.find_elements(By.TAG_NAME, "iframe")
                for iframe in iframes:
                    self.driver.switch_to.frame(iframe)
                    try:
                        fechar_alerta = WebDriverWait(self.driver, 5).until(
                            EC.element_to_be_clickable((By.XPATH, "//a[contains(@id, 'wt15')]/span[contains(@class, 'fa-close')]"))
                        )
                        fechar_alerta.click()
                        logging.info("Alerta detectado e fechado dentro de um iframe.")
                        self.driver.switch_to.default_content()
                        self.wait_for_stability(timeout=5)
                        break  # Sai do loop após fechar o alerta
                    except TimeoutException:
                        self.driver.switch_to.default_content()
                        continue
            except Exception as e:
                pass

            self.wait_for_stability(timeout=10)

            link_portal_webplan = self.acessar_com_reattempt((By.XPATH, "//*[@id='IpasgoTheme_wt16_block_wtMainContent_wtSistemas_ctl08_SilkUIFramework_wt36_block_wtActions_wtModulos_SilkUIFramework_wt9_block_wtContent_wtModuloPortalTable_ctl04_wt2']/span"))
            self.scroll_and_click(link_portal_webplan)

            WebDriverWait(self.driver, 20).until(EC.number_of_windows_to_be(2))
            self.driver.switch_to.window(self.driver.window_handles[1])

            self.acessar_com_reattempt((By.ID, "menuPrincipal"))

            time.sleep(4)
#########################################################
#chamando a função executar_fluxo: 
#########################################################
            self.executar_fluxo()
        except Exception as e:
            pass 


    def executar_fluxo(self):
        """Executa o fluxo de interações após o login no portal IPASGO."""
        try:
            self.localizar_procedimentos()
            self.Guia_operadora()
            self.abrir_confirmar_procedimentos()
            # Se desejar, pode adicionar mais funções aqui
        except Exception as e:
            raise


    def scroll_and_click(self, element):
        """Rola a página para o elemento e clica nele."""
        self.driver.execute_script("arguments[0].scrollIntoView(true);", element)
        time.sleep(2)
        element.click()

    def localizar_procedimentos(self):
        """Função para localizar e clicar no elemento 'localizar-procedimentos'."""
        try:
            logging.info("Localizando o menu de procedimentos.")
            procedimentos_button = self.acessar_com_reattempt((By.CSS_SELECTOR, ".localizar-procedimentos-icon"))
            self.scroll_and_click(procedimentos_button)
            time.sleep(5)

            # Verifica se o alerta aparece e lida com ele se necessário
            self.close_alert_if_present()

        except Exception as e:
            pass #logging.error(f"Erro ao acessar o menu de procedimentos: {e}")

    def close_alert_if_present(self):
        """Fecha o alerta se estiver presente."""
        try:
            logging.info("Verificando se o alerta está presente.")
            alerta = WebDriverWait(self.driver, 5).until(EC.visibility_of_element_located((By.XPATH, '//*[@id="button-1"]')))
            alerta.click()
            logging.info("Alerta fechado com sucesso.")
        except TimeoutException:
            logging.info("Nenhum alerta encontrado, continuando o processo.")

    def Guia_operadora(self):
        """Função para inserir o número da guia para localizar procedimento usando dados da planilha."""
        try:
            numero_guia = self.get_excel_value('Guia_Cod')
            logging.info("Localizando o campo de número da guia.")

            guia_input = self.acessar_com_reattempt((By.CSS_SELECTOR, 'div.input-group > input.form-control.small'))
            guia_input.send_keys(str(numero_guia))
            logging.info(f"Número da guia preenchido com sucesso:{numero_guia}")

            search_button = self.acessar_com_reattempt((By.XPATH, "//div[contains(@class, 'input-group')]//span[contains(@class, 'fa-search') and contains(@class, 'pointer')]"))
            search_button.click()

            time.sleep(2)

            self.driver.execute_script("window.scrollTo(0, document.body.scrollHeight);")
            time.sleep(2)

        except Exception as e:
            pass #logging.error(f"Erro ao tentar preencher o número da guia: {e}")

    def abrir_confirmar_procedimentos(self):
        """Função para confirmar procedimentos executados."""
        try:
            logging.info("Iniciando o processo de confirmação dos procedimentos.")
            confirmar_button = self.acessar_com_reattempt((By.XPATH, '//*[@id="localizarprocedimentos"]/div[2]/div/div[2]/div/div[2]/div[1]/div/div/div/div[2]/div[2]/div/div[1]/div/div[1]/div[2]/div/i[2]'))
            confirmar_button.click()
            logging.info("Botão de confirmação clicado com sucesso.")
            time.sleep(2)
            self.confirmar_procedimentos()
        except Exception as e:
            logging.error(f"Erro ao tentar confirmar os procedimentos: {e}")

    def confirmar_procedimentos(self):
        
        """Captura os textos de confirmação dos procedimentos exibidos no modal."""
        try:
            logging.info("Iniciando captura de confirmações dos procedimentos.")

            # Aguardando a presença do modal
            modal = WebDriverWait(self.driver, 10).until(
                EC.visibility_of_element_located((By.XPATH, '//*[@id="confirmar-procedimentos-modal"]'))
            )

            # Localiza todos os itens de confirmação dentro do modal
            confirmacao_itens = modal.find_elements(By.XPATH, '//*[@id="confirmar-procedimentos-modal"]/div/div/div[2]/div[2]/div/div[2]/div/div')

            confirmacoes = []
            
            for item in confirmacao_itens:
                # Captura o texto do elemento de confirmação
                texto_confirmacao = item.find_element(By.XPATH, './/span[starts-with(@data-bind, "text: IsConfirmado()")]').text
                confirmacoes.append(texto_confirmacao)
                logging.info(f"Confirmação capturada: {texto_confirmacao}")

            # Retorna todas as confirmações capturadas
            return confirmacoes

        except Exception as e:
            logging.error(f"Erro ao capturar confirmações: {e}")


# Exemplo de execução
if __name__ == "__main__":
    automacao = VerificationIPASGO()
    automacao.acessar_portal_ipasgo()
