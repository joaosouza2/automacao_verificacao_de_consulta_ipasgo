import openpyxl
import logging
import time
import pandas as pd
import sys
import os
from pathlib import Path
from selenium import webdriver
from selenium.webdriver.chrome.options import Options
from selenium.webdriver.common.by import By
from selenium.webdriver.support.ui import WebDriverWait, Select
from selenium.webdriver.support import expected_conditions as EC
from selenium.common.exceptions import TimeoutException, NoSuchElementException
from selenium.webdriver.common.keys import Keys

# Configuração de logging aprimorada
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(levelname)s - %(name)s - %(message)s',
    handlers=[
        logging.FileHandler("automacao.log"),
        logging.StreamHandler()
    ]
)

# Definir um excepthook para capturar exceções não tratadas
def excepthook(exc_type, exc_value, exc_traceback):
    if issubclass(exc_type, KeyboardInterrupt):
        # Permite que o KeyboardInterrupt seja tratado normalmente
        sys.__excepthook__(exc_type, exc_value, exc_traceback)
        return
    logging.error(f"Exceção não capturada: {exc_value}")

sys.excepthook = excepthook

class NumeroCarteiraNaoEncontradoException(Exception):
    """Exceção para indicar que o número da carteira não foi encontrado no Excel."""
    pass

class DataHandler:
    def __init__(self, file_path, sheet_name):
        """Inicializa o manipulador de dados com o caminho do arquivo e o nome da planilha."""
        self.file_path = file_path
        self.sheet_name = sheet_name
        self.df = pd.read_excel(file_path, sheet_name=sheet_name)
        self.df.columns = [col.upper().strip() for col in self.df.columns]
        if 'CONFIRMACOES' not in self.df.columns:
            self.df['CONFIRMACOES'] = ''
        if 'ERRO' not in self.df.columns:
            self.df['ERRO'] = ''

    def get_value(self, row_index, column_name):
        """Obtém o valor de uma coluna específica em uma linha específica."""
        try:
            value = self.df.at[row_index, column_name.upper()]
            if pd.isnull(value):
                return ""
            if isinstance(value, float) and value.is_integer():
                return str(int(value))
            return str(value).strip()
        except KeyError:
            logging.error(f"A coluna '{column_name}' não foi encontrada.")
            return ""

    def update_value(self, row_index, column_name, value):
        """Atualiza o valor de uma célula específica."""
        try:
            self.df.at[row_index, column_name.upper()] = value
            logging.info(f"Valor atualizado na linha {row_index + 2}, coluna '{column_name}': {value}")
        except KeyError:
            logging.error(f"A coluna '{column_name}' não foi encontrada ao tentar atualizar o valor.")

    def save(self):
        """Salva o DataFrame de volta ao arquivo Excel."""
        try:
            self.df.to_excel(self.file_path, sheet_name=self.sheet_name, index=False)
            logging.info(f"Alterações salvas no arquivo Excel com sucesso: {self.file_path}")
        except Exception as e:
            error_message = getattr(e, 'message', str(e))
            logging.error(f"Erro ao salvar o arquivo Excel: {error_message}")

class BaseAutomation:
    def __init__(self):
        """Configurações gerais do WebDriver."""
        self.options = Options()
        self.options.add_argument("--start-maximized")
        self.driver = webdriver.Chrome(options=self.options)

    def wait_for_stability(self, timeout=10, check_interval=1):
        """Espera pela estabilidade da altura da página."""
        old_height = self.driver.execute_script("return document.body.scrollHeight;")
        for _ in range(timeout):
            time.sleep(check_interval)
            new_height = self.driver.execute_script("return document.body.scrollHeight;")
            if new_height == old_height:
                break
            old_height = new_height

    def safe_click(self, by_locator):
        """Tenta clicar no elemento várias vezes se for interceptado."""
        for _ in range(3):
            try:
                element = WebDriverWait(self.driver, 5).until(EC.element_to_be_clickable(by_locator))
                element.click()
                logging.info(f"Elemento clicado com sucesso: {by_locator}")
                return
            except Exception as e:
                error_message = getattr(e, 'msg', str(e))
                logging.warning(f"Erro ao clicar no elemento: {error_message}")
                time.sleep(1)
        raise Exception("Não foi possível clicar no elemento após várias tentativas.")

    def acessar_com_reattempt(self, by_locator, attempts=3):
        """Tenta acessar um elemento várias vezes."""
        for attempt in range(attempts):
            try:
                element = WebDriverWait(self.driver, 10).until(EC.element_to_be_clickable(by_locator))
                logging.info(f"Elemento encontrado: {by_locator}")
                return element
            except TimeoutException:
                logging.warning(f"Tentativa {attempt + 1} falhou. Tentando novamente...")
                time.sleep(1)
        raise Exception(f"Não foi possível acessar o elemento após {attempts} tentativas.")

    def __enter__(self):
        """Método chamado ao entrar no contexto 'with'."""
        return self

    def __exit__(self, exc_type, exc_value, traceback):
        """Método chamado ao sair do contexto 'with'."""
        self.driver.quit()

class VerificationIPASGO(BaseAutomation):
    def __init__(self, data_handler):
        super().__init__()
        self.data_handler = data_handler
        self.row_index = 0  # Inicie com o índice desejado

        # Caminho para o arquivo  onde as confirmações serão salvas
        self.txt_file_path = r"C:\Users\SUPERVISÃO ADM\Desktop\RPA_verificação_ipasgo\salvamento_datas_confirmação.txt"

        # Obter as credenciais das variáveis de ambiente
        self.username = os.environ.get('IPASGO_USERNAME')
        self.password = os.environ.get('IPASGO_PASSWORD')
        if not self.username or not self.password:
            raise Exception("As credenciais não foram encontradas nas variáveis de ambiente.")

    def acessar_portal_ipasgo(self):
        """Executa o fluxo principal do IPASGO."""
        try:
            self.driver.get("https://portalos.ipasgo.go.gov.br/Portal_Dominio/PrestadorLogin.aspx")
            self.wait_for_stability(timeout=10)

            matricula_input = self.acessar_com_reattempt((By.ID, "SilkUIFramework_wt13_block_wtUsername_wtUserNameInput2"))
            matricula_input.send_keys(self.username)

            senha_input = self.acessar_com_reattempt((By.ID, "SilkUIFramework_wt13_block_wtPassword_wtPasswordInput"))
            senha_input.send_keys(self.password)

            self.safe_click((By.ID, "SilkUIFramework_wt13_block_wtAction_wtLoginButton"))

            # Verificar se o alerta está dentro de um iframe (opcional)
            try:
                iframes = self.driver.find_elements(By.TAG_NAME, "iframe")
                for iframe in iframes:
                    self.driver.switch_to.frame(iframe)
                    try:
                        fechar_alerta = WebDriverWait(self.driver, 5).until(
                            EC.element_to_be_clickable((By.XPATH, "//a[contains(@id, 'wt15')]/span[contains(@class, 'fa-close')]"))
                        )
                        fechar_alerta.click()
                        logging.info("Alerta detectado e fechado dentro de um iframe.")
                        self.driver.switch_to.default_content()
                        self.wait_for_stability(timeout=5)
                        break
                    except TimeoutException:
                        self.driver.switch_to.default_content()
                        continue
            except Exception:
                pass

            self.wait_for_stability(timeout=10)

            link_portal_webplan = self.acessar_com_reattempt((By.XPATH, "//*[@id='IpasgoTheme_wt16_block_wtMainContent_wtSistemas_ctl08_SilkUIFramework_wt36_block_wtActions_wtModulos_SilkUIFramework_wt9_block_wtContent_wtModuloPortalTable_ctl04_wt2']/span"))
            self.scroll_and_click(link_portal_webplan)

            WebDriverWait(self.driver, 20).until(EC.number_of_windows_to_be(2))
            self.driver.switch_to.window(self.driver.window_handles[1])

            self.acessar_com_reattempt((By.ID, "menuPrincipal"))

            time.sleep(4)
            self.executar_fluxo()
        except Exception as e:
            error_message = getattr(e, 'msg', str(e))
            logging.error(f"Erro ao acessar o portal IPASGO: {error_message}")

    def executar_fluxo(self):
        """Executa o fluxo de interações após o login no portal IPASGO."""
        try:
            self.localizar_procedimentos()
            self.Guia_operadora()
            self.abrir_confirmar_procedimentos()
            logging.info("Fluxo concluído. Aguardando para análise.")
            input("Pressione Enter para encerrar o script.")
        except Exception as e:
            error_message = getattr(e, 'msg', str(e))
            logging.error(f"Erro ao executar o fluxo: {error_message}")

    def scroll_and_click(self, element):
        """Rola a página para o elemento e clica nele."""
        self.driver.execute_script("arguments[0].scrollIntoView(true);", element)
        time.sleep(2)
        element.click()

    def localizar_procedimentos(self):
        """Função para localizar e clicar no elemento 'localizar-procedimentos'."""
        try:
            logging.info("Localizando o menu de procedimentos.")
            procedimentos_button = self.acessar_com_reattempt((By.CSS_SELECTOR, ".localizar-procedimentos-icon"))
            self.scroll_and_click(procedimentos_button)
            time.sleep(5)
            self.close_alert_if_present()
        except Exception as e:
            error_message = getattr(e, 'msg', str(e))
            logging.error(f"Erro ao acessar o menu de procedimentos: {error_message}")

    def close_alert_if_present(self):
        """Fecha o alerta se estiver presente."""
        try:
            logging.info("Verificando se o alerta está presente.")
            alerta = WebDriverWait(self.driver, 5).until(EC.visibility_of_element_located((By.XPATH, '//*[@id="button-1"]')))
            alerta.click()
            logging.info("Alerta fechado com sucesso.")
        except TimeoutException:
            logging.info("Nenhum alerta encontrado, continuando o processo.")

    def Guia_operadora(self):
        """Função para inserir o número da guia para localizar procedimento usando dados da planilha."""
        try:
            numero_guia = self.data_handler.get_value(self.row_index, 'GUIA_COD')
            logging.info("Localizando o campo de número da guia.")

            guia_input = self.acessar_com_reattempt((By.CSS_SELECTOR, 'div.input-group > input.form-control.small'))
            guia_input.send_keys(str(numero_guia))
            logging.info(f"Número da guia preenchido com sucesso: {numero_guia}")

            search_button = self.acessar_com_reattempt((By.XPATH, "//div[contains(@class, 'input-group')]//span[contains(@class, 'fa-search') and contains(@class, 'pointer')]"))
            search_button.click()

            time.sleep(2)

            self.driver.execute_script("window.scrollTo(0, document.body.scrollHeight);")
            time.sleep(2)

        except Exception as e:
            error_message = getattr(e, 'msg', str(e))
            logging.error(f"Erro ao preencher o número da guia: {error_message}")

    def abrir_confirmar_procedimentos(self):
        """Função para confirmar procedimentos executados."""
        try:
            logging.info("Iniciando o processo de confirmação dos procedimentos.")
            confirmar_button = self.acessar_com_reattempt((By.XPATH, '//*[@id="localizarprocedimentos"]/div[2]/div/div[2]/div/div[2]/div[1]/div/div/div/div[2]/div[2]/div/div[1]/div/div[1]/div[2]/div/i[2]'))
            confirmar_button.click()
            logging.info("Botão de confirmação clicado com sucesso.")
            time.sleep(2)
            self.confirmar_data_procedimentos()
        except Exception as e:
            error_message = getattr(e, 'msg', str(e))
            logging.error(f"Erro ao tentar confirmar os procedimentos: {error_message}")

    def confirmar_data_procedimentos(self):
        """Captura os textos de confirmação dos procedimentos exibidos no modal e salva em uma lista."""
        try:
            logging.info("Iniciando captura de confirmações dos procedimentos.")

            modal = WebDriverWait(self.driver, 10).until(
                EC.visibility_of_element_located((By.ID, 'confirmar-procedimentos-modal'))
            )
            logging.info("Modal de confirmação está visível.")

            confirmacao_itens = modal.find_elements(By.XPATH, '//*[@id="confirmar-procedimentos-modal"]/div/div/div[2]/div[2]/div/div[2]/div/div')

            self.confirmation_status_list = []

            for idx, item in enumerate(confirmacao_itens):
                texto_confirmacao = item.find_element(By.XPATH, './/span[starts-with(@data-bind, "text: IsConfirmado()")]').text.strip()
                self.confirmation_status_list.append(texto_confirmacao)
                logging.info(f"Confirmação capturada na posição {idx + 1}: {texto_confirmacao}")

            confirmacoes_texto = "; ".join(self.confirmation_status_list)
            self.data_handler.update_value(self.row_index, 'CONFIRMACOES', confirmacoes_texto)
            self.data_handler.save()

            with open(self.txt_file_path, 'a', encoding='utf-8') as f:
                f.write(f"Linha {self.row_index + 2}: {confirmacoes_texto}\n")

            logging.info(f"Confirmações capturadas e salvas em '{self.txt_file_path}'.")

            self.Clicar_confirmar_procedimento()

        except Exception as e:
            logging.error(f"Erro ao capturar confirmações: {e}")

    def Clicar_confirmar_procedimento(self):
        """Processa o primeiro procedimento não confirmado."""
        try:
            idx = self.obter_indice_nao_confirmado()
            if idx is None:
                logging.info("Todos os procedimentos já estão confirmados.")
                return

            self.confirmar_procedimento(idx)
            self.atualizar_confirmacoes()
        except NumeroCarteiraNaoEncontradoException as e:
            logging.error(e)
            self.data_handler.update_value(self.row_index, 'ERRO', str(e))
            self.data_handler.save()
        except Exception as e:
            logging.error(f"Erro ao processar o procedimento: {e}")
            self.data_handler.update_value(self.row_index, 'ERRO', str(e))
            self.data_handler.save()

    def obter_indice_nao_confirmado(self):
        """Retorna o índice do primeiro procedimento 'Não confirmado'."""
        for idx, status in enumerate(self.confirmation_status_list):
            if status == "Não confirmado":
                return idx
        return None

    def confirmar_procedimento(self, idx):
        """Confirma o procedimento no índice especificado."""
        position = idx + 1
        logging.info(f"Confirmando procedimento na posição {position}.")
        item_xpath = f'//*[@id="confirmar-procedimentos-modal"]/div/div/div[2]/div[2]/div/div[2]/div/div[{position}]'

        item = self.driver.find_element(By.XPATH, item_xpath)
        confirm_button = item.find_element(By.XPATH, './/*[@id="span-cartao-magnetico"]/span[1]')
        confirm_button.click()
        time.sleep(1)
        

        self.preencher_numero_carteira()
        #self.clicar_botao_confirmar()
        self.aguardar_confirmacao(item, idx)

    def preencher_numero_carteira(self):
        """Preenche o campo 'numeroDaCarteiraConfirmacao' com o número da carteira."""
        campo_carteira = WebDriverWait(self.driver, 10).until(
            EC.visibility_of_element_located((By.ID, 'numeroDaCarteiraConfirmacao'))
        )
        numero_carteira = self.data_handler.get_value(self.row_index, 'COLUNA1')
        
        if not numero_carteira:
            raise NumeroCarteiraNaoEncontradoException("Número da carteira não encontrado no Excel.")

        numero_carteira = numero_carteira.split('.')[0] if '.' in numero_carteira else numero_carteira

        campo_carteira.send_keys(numero_carteira)
        logging.info(f"Número da carteira '{numero_carteira}' preenchido.")
          # Aguarde 1 segundo
        time.sleep(1)
                            
        # Simular a seta para baixo e pressionar Enter
        campo_carteira.send_keys(Keys.ARROW_DOWN)
        campo_carteira.send_keys(Keys.ENTER)
        logging.info("Seta para baixo e Enter pressionados para selecionar a opção correta.")

    def clicar_botao_confirmar(self):
        """Clica no botão de confirmar após preencher o número da carteira."""
        botao_confirmar = WebDriverWait(self.driver, 10).until(
            EC.element_to_be_clickable((By.XPATH, '//button[contains(@class, "confirmar-procedimento-btn")]'))
        )
        botao_confirmar.click()
        logging.info("Botão de confirmação clicado com sucesso.")

    def aguardar_confirmacao(self, item, idx):
        """Aguarda a atualização do status para 'Confirmado'."""
        status_element = item.find_element(By.XPATH, './/span[starts-with(@data-bind, "text: IsConfirmado()")]')
        WebDriverWait(self.driver, 10).until(
            lambda driver: "Confirmado" in status_element.text
        )
        updated_status = status_element.text.strip()
        logging.info(f"Procedimento confirmado: {updated_status}")
        self.confirmation_status_list[idx] = updated_status

    def atualizar_confirmacoes(self):
        """Atualiza as confirmações no Excel e no arquivo de texto."""
        confirmacoes_texto = "; ".join(self.confirmation_status_list)
        self.data_handler.update_value(self.row_index, 'CONFIRMACOES', confirmacoes_texto)
        self.data_handler.save()

        with open(self.txt_file_path, 'a', encoding='utf-8') as f:
            f.write(f"Linha {self.row_index + 2}: {confirmacoes_texto}\n")
        logging.info(f"Confirmações atualizadas e salvas.")

# Exemplo de execução
if __name__ == "__main__":
    # Defina o caminho do arquivo e o nome da planilha
    file_path = r"C:\Users\SUPERVISÃO ADM\Desktop\RPA_verificação_ipasgo\BASE_GUIAS_IPASGO_10-2024tTEST.xlsx"
    sheet_name = 'BaseSADT'

    # Crie uma instância de DataHandler
    data_handler = DataHandler(file_path, sheet_name)

    # Use 'with' para gerenciar o contexto do WebDriver
    with VerificationIPASGO(data_handler) as automacao:
        # Defina o intervalo de linhas que deseja processar
        start_row = 8
        end_row = len(data_handler.df) - 1  # Processa todas as linhas

        # Itere sobre as linhas e processe cada uma
        for idx in range(start_row, end_row + 1):
            automacao.row_index = idx
            logging.info(f"Iniciando o processamento da linha {idx + 2}")
            try:
                automacao.acessar_portal_ipasgo()
                # Salve as alterações após processar cada linha
                data_handler.save()
                # Parar o loop após a execução
                break  # Remova esta linha se quiser continuar para as próximas linhas

            except Exception as e:
                error_message = getattr(e, 'msg', str(e))
                logging.error(f"Erro ao processar a linha {idx + 2}: {error_message}")
                # Atualiza a coluna 'ERRO' no Excel
                data_handler.update_value(idx, 'ERRO', error_message)
                data_handler.save()
                break  # Remova esta linha se quiser continuar para as próximas linhas
